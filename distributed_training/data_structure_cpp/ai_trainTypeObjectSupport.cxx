// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file ai_trainTypeObjectSupport.cxx
 * Source file containing the implementation to register the TypeObject representation of the described types in the IDL file
 *
 * This file was generated by the tool fastddsgen (version: 4.1.0).
 */

#include "ai_trainTypeObjectSupport.hpp"

#include <mutex>
#include <string>

#include <fastcdr/xcdr/external.hpp>
#include <fastcdr/xcdr/optional.hpp>
#include <fastdds/dds/domain/DomainParticipantFactory.hpp>
#include <fastdds/dds/log/Log.hpp>
#include <fastdds/dds/xtypes/common.hpp>
#include <fastdds/dds/xtypes/type_representation/ITypeObjectRegistry.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObject.hpp>
#include <fastdds/dds/xtypes/type_representation/TypeObjectUtils.hpp>
#include "ai_train.hpp"


using namespace eprosima::fastdds::dds::xtypes;

namespace ai_train {
void register_RoundId_type_identifier(
        TypeIdentifierPair& type_ids_RoundId)
{
    ReturnCode_t return_code_RoundId {eprosima::fastdds::dds::RETCODE_OK};
    return_code_RoundId =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::RoundId", type_ids_RoundId);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_RoundId)
    {
        AliasTypeFlag alias_flags_RoundId = 0;
        QualifiedTypeName type_name_RoundId = "ai_train::RoundId";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_RoundId;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_RoundId;
        CompleteTypeDetail detail_RoundId = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_RoundId, ann_custom_RoundId, type_name_RoundId.to_string());
        CompleteAliasHeader header_RoundId = TypeObjectUtils::build_complete_alias_header(detail_RoundId);
        AliasMemberFlag related_flags_RoundId = 0;
        return_code_RoundId =
            eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
            "_uint32_t", type_ids_RoundId);

        if (eprosima::fastdds::dds::RETCODE_OK != return_code_RoundId)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "ai_train::RoundId related TypeIdentifier unknown to TypeObjectRegistry.");
            return;
        }
        bool common_RoundId_ec {false};
        CommonAliasBody common_RoundId {TypeObjectUtils::build_common_alias_body(related_flags_RoundId,
                TypeObjectUtils::retrieve_complete_type_identifier(type_ids_RoundId, common_RoundId_ec))};
        if (!common_RoundId_ec)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "ai_train::RoundId related TypeIdentifier inconsistent.");
            return;
        }
        eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_RoundId;
        ann_custom_RoundId.reset();
        CompleteAliasBody body_RoundId = TypeObjectUtils::build_complete_alias_body(common_RoundId,
                member_ann_builtin_RoundId, ann_custom_RoundId);
        CompleteAliasType alias_type_RoundId = TypeObjectUtils::build_complete_alias_type(alias_flags_RoundId,
                header_RoundId, body_RoundId);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_alias_type_object(alias_type_RoundId,
                    type_name_RoundId.to_string(), type_ids_RoundId))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "ai_train::RoundId already registered in TypeObjectRegistry for a different type.");
        }
    }
}

void register_ClientId_type_identifier(
        TypeIdentifierPair& type_ids_ClientId)
{
    ReturnCode_t return_code_ClientId {eprosima::fastdds::dds::RETCODE_OK};
    return_code_ClientId =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::ClientId", type_ids_ClientId);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_ClientId)
    {
        AliasTypeFlag alias_flags_ClientId = 0;
        QualifiedTypeName type_name_ClientId = "ai_train::ClientId";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_ClientId;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_ClientId;
        CompleteTypeDetail detail_ClientId = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_ClientId, ann_custom_ClientId, type_name_ClientId.to_string());
        CompleteAliasHeader header_ClientId = TypeObjectUtils::build_complete_alias_header(detail_ClientId);
        AliasMemberFlag related_flags_ClientId = 0;
        return_code_ClientId =
            eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
            "_uint32_t", type_ids_ClientId);

        if (eprosima::fastdds::dds::RETCODE_OK != return_code_ClientId)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "ai_train::ClientId related TypeIdentifier unknown to TypeObjectRegistry.");
            return;
        }
        bool common_ClientId_ec {false};
        CommonAliasBody common_ClientId {TypeObjectUtils::build_common_alias_body(related_flags_ClientId,
                TypeObjectUtils::retrieve_complete_type_identifier(type_ids_ClientId, common_ClientId_ec))};
        if (!common_ClientId_ec)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "ai_train::ClientId related TypeIdentifier inconsistent.");
            return;
        }
        eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_ClientId;
        ann_custom_ClientId.reset();
        CompleteAliasBody body_ClientId = TypeObjectUtils::build_complete_alias_body(common_ClientId,
                member_ann_builtin_ClientId, ann_custom_ClientId);
        CompleteAliasType alias_type_ClientId = TypeObjectUtils::build_complete_alias_type(alias_flags_ClientId,
                header_ClientId, body_ClientId);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_alias_type_object(alias_type_ClientId,
                    type_name_ClientId.to_string(), type_ids_ClientId))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "ai_train::ClientId already registered in TypeObjectRegistry for a different type.");
        }
    }
}

void register_Bytes_type_identifier(
        TypeIdentifierPair& type_ids_Bytes)
{
    ReturnCode_t return_code_Bytes {eprosima::fastdds::dds::RETCODE_OK};
    return_code_Bytes =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::Bytes", type_ids_Bytes);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_Bytes)
    {
        AliasTypeFlag alias_flags_Bytes = 0;
        QualifiedTypeName type_name_Bytes = "ai_train::Bytes";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_Bytes;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_Bytes;
        CompleteTypeDetail detail_Bytes = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_Bytes, ann_custom_Bytes, type_name_Bytes.to_string());
        CompleteAliasHeader header_Bytes = TypeObjectUtils::build_complete_alias_header(detail_Bytes);
        AliasMemberFlag related_flags_Bytes = 0;
        return_code_Bytes =
            eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
            "anonymous_sequence_byte_unbounded", type_ids_Bytes);

        if (eprosima::fastdds::dds::RETCODE_OK != return_code_Bytes)
        {
            return_code_Bytes =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_byte", type_ids_Bytes);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_Bytes)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "Sequence element TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            bool element_identifier_anonymous_sequence_byte_unbounded_ec {false};
            TypeIdentifier* element_identifier_anonymous_sequence_byte_unbounded {new TypeIdentifier(TypeObjectUtils::retrieve_complete_type_identifier(type_ids_Bytes, element_identifier_anonymous_sequence_byte_unbounded_ec))};
            if (!element_identifier_anonymous_sequence_byte_unbounded_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Sequence element TypeIdentifier inconsistent.");
                return;
            }
            EquivalenceKind equiv_kind_anonymous_sequence_byte_unbounded = EK_COMPLETE;
            if (TK_NONE == type_ids_Bytes.type_identifier2()._d())
            {
                equiv_kind_anonymous_sequence_byte_unbounded = EK_BOTH;
            }
            CollectionElementFlag element_flags_anonymous_sequence_byte_unbounded = 0;
            PlainCollectionHeader header_anonymous_sequence_byte_unbounded = TypeObjectUtils::build_plain_collection_header(equiv_kind_anonymous_sequence_byte_unbounded, element_flags_anonymous_sequence_byte_unbounded);
            {
                SBound bound = 0;
                PlainSequenceSElemDefn seq_sdefn = TypeObjectUtils::build_plain_sequence_s_elem_defn(header_anonymous_sequence_byte_unbounded, bound,
                            eprosima::fastcdr::external<TypeIdentifier>(element_identifier_anonymous_sequence_byte_unbounded));
                if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                        TypeObjectUtils::build_and_register_s_sequence_type_identifier(seq_sdefn, "anonymous_sequence_byte_unbounded", type_ids_Bytes))
                {
                    EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "anonymous_sequence_byte_unbounded already registered in TypeObjectRegistry for a different type.");
                }
            }
        }
        bool common_Bytes_ec {false};
        CommonAliasBody common_Bytes {TypeObjectUtils::build_common_alias_body(related_flags_Bytes,
                TypeObjectUtils::retrieve_complete_type_identifier(type_ids_Bytes, common_Bytes_ec))};
        if (!common_Bytes_ec)
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "ai_train::Bytes related TypeIdentifier inconsistent.");
            return;
        }
        eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_Bytes;
        ann_custom_Bytes.reset();
        CompleteAliasBody body_Bytes = TypeObjectUtils::build_complete_alias_body(common_Bytes,
                member_ann_builtin_Bytes, ann_custom_Bytes);
        CompleteAliasType alias_type_Bytes = TypeObjectUtils::build_complete_alias_type(alias_flags_Bytes,
                header_Bytes, body_Bytes);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_alias_type_object(alias_type_Bytes,
                    type_name_Bytes.to_string(), type_ids_Bytes))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                "ai_train::Bytes already registered in TypeObjectRegistry for a different type.");
        }
    }
}

// TypeIdentifier is returned by reference: dependent structures/unions are registered in this same method
void register_TrainCmd_type_identifier(
        TypeIdentifierPair& type_ids_TrainCmd)
{

    ReturnCode_t return_code_TrainCmd {eprosima::fastdds::dds::RETCODE_OK};
    return_code_TrainCmd =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::TrainCmd", type_ids_TrainCmd);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_TrainCmd)
    {
        StructTypeFlag struct_flags_TrainCmd = TypeObjectUtils::build_struct_type_flag(eprosima::fastdds::dds::xtypes::ExtensibilityKind::APPENDABLE,
                false, false);
        QualifiedTypeName type_name_TrainCmd = "ai_train::TrainCmd";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_TrainCmd;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_TrainCmd;
        CompleteTypeDetail detail_TrainCmd = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_TrainCmd, ann_custom_TrainCmd, type_name_TrainCmd.to_string());
        CompleteStructHeader header_TrainCmd;
        header_TrainCmd = TypeObjectUtils::build_complete_struct_header(TypeIdentifier(), detail_TrainCmd);
        CompleteStructMemberSeq member_seq_TrainCmd;
        {
            TypeIdentifierPair type_ids_round_id;
            ReturnCode_t return_code_round_id {eprosima::fastdds::dds::RETCODE_OK};
            return_code_round_id =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::RoundId", type_ids_round_id);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_round_id)
            {
                ::ai_train::register_RoundId_type_identifier(type_ids_round_id);
            }
            StructMemberFlag member_flags_round_id = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_round_id = 0x00000000;
            bool common_round_id_ec {false};
            CommonStructMember common_round_id {TypeObjectUtils::build_common_struct_member(member_id_round_id, member_flags_round_id, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_round_id, common_round_id_ec))};
            if (!common_round_id_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure round_id member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_round_id = "round_id";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_round_id;
            ann_custom_TrainCmd.reset();
            CompleteMemberDetail detail_round_id = TypeObjectUtils::build_complete_member_detail(name_round_id, member_ann_builtin_round_id, ann_custom_TrainCmd);
            CompleteStructMember member_round_id = TypeObjectUtils::build_complete_struct_member(common_round_id, detail_round_id);
            TypeObjectUtils::add_complete_struct_member(member_seq_TrainCmd, member_round_id);
        }
        {
            TypeIdentifierPair type_ids_subset_size;
            ReturnCode_t return_code_subset_size {eprosima::fastdds::dds::RETCODE_OK};
            return_code_subset_size =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_uint32_t", type_ids_subset_size);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_subset_size)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "subset_size Structure member TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            StructMemberFlag member_flags_subset_size = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_subset_size = 0x00000001;
            bool common_subset_size_ec {false};
            CommonStructMember common_subset_size {TypeObjectUtils::build_common_struct_member(member_id_subset_size, member_flags_subset_size, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_subset_size, common_subset_size_ec))};
            if (!common_subset_size_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure subset_size member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_subset_size = "subset_size";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_subset_size;
            ann_custom_TrainCmd.reset();
            CompleteMemberDetail detail_subset_size = TypeObjectUtils::build_complete_member_detail(name_subset_size, member_ann_builtin_subset_size, ann_custom_TrainCmd);
            CompleteStructMember member_subset_size = TypeObjectUtils::build_complete_struct_member(common_subset_size, detail_subset_size);
            TypeObjectUtils::add_complete_struct_member(member_seq_TrainCmd, member_subset_size);
        }
        {
            TypeIdentifierPair type_ids_epochs;
            ReturnCode_t return_code_epochs {eprosima::fastdds::dds::RETCODE_OK};
            return_code_epochs =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_uint32_t", type_ids_epochs);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_epochs)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "epochs Structure member TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            StructMemberFlag member_flags_epochs = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_epochs = 0x00000002;
            bool common_epochs_ec {false};
            CommonStructMember common_epochs {TypeObjectUtils::build_common_struct_member(member_id_epochs, member_flags_epochs, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_epochs, common_epochs_ec))};
            if (!common_epochs_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure epochs member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_epochs = "epochs";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_epochs;
            ann_custom_TrainCmd.reset();
            CompleteMemberDetail detail_epochs = TypeObjectUtils::build_complete_member_detail(name_epochs, member_ann_builtin_epochs, ann_custom_TrainCmd);
            CompleteStructMember member_epochs = TypeObjectUtils::build_complete_struct_member(common_epochs, detail_epochs);
            TypeObjectUtils::add_complete_struct_member(member_seq_TrainCmd, member_epochs);
        }
        {
            TypeIdentifierPair type_ids_lr;
            ReturnCode_t return_code_lr {eprosima::fastdds::dds::RETCODE_OK};
            return_code_lr =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_double", type_ids_lr);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_lr)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "lr Structure member TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            StructMemberFlag member_flags_lr = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_lr = 0x00000003;
            bool common_lr_ec {false};
            CommonStructMember common_lr {TypeObjectUtils::build_common_struct_member(member_id_lr, member_flags_lr, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_lr, common_lr_ec))};
            if (!common_lr_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure lr member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_lr = "lr";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_lr;
            ann_custom_TrainCmd.reset();
            CompleteMemberDetail detail_lr = TypeObjectUtils::build_complete_member_detail(name_lr, member_ann_builtin_lr, ann_custom_TrainCmd);
            CompleteStructMember member_lr = TypeObjectUtils::build_complete_struct_member(common_lr, detail_lr);
            TypeObjectUtils::add_complete_struct_member(member_seq_TrainCmd, member_lr);
        }
        {
            TypeIdentifierPair type_ids_seed;
            ReturnCode_t return_code_seed {eprosima::fastdds::dds::RETCODE_OK};
            return_code_seed =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_uint32_t", type_ids_seed);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_seed)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "seed Structure member TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            StructMemberFlag member_flags_seed = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_seed = 0x00000004;
            bool common_seed_ec {false};
            CommonStructMember common_seed {TypeObjectUtils::build_common_struct_member(member_id_seed, member_flags_seed, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_seed, common_seed_ec))};
            if (!common_seed_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure seed member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_seed = "seed";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_seed;
            ann_custom_TrainCmd.reset();
            CompleteMemberDetail detail_seed = TypeObjectUtils::build_complete_member_detail(name_seed, member_ann_builtin_seed, ann_custom_TrainCmd);
            CompleteStructMember member_seed = TypeObjectUtils::build_complete_struct_member(common_seed, detail_seed);
            TypeObjectUtils::add_complete_struct_member(member_seq_TrainCmd, member_seed);
        }
        CompleteStructType struct_type_TrainCmd = TypeObjectUtils::build_complete_struct_type(struct_flags_TrainCmd, header_TrainCmd, member_seq_TrainCmd);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_struct_type_object(struct_type_TrainCmd, type_name_TrainCmd.to_string(), type_ids_TrainCmd))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "ai_train::TrainCmd already registered in TypeObjectRegistry for a different type.");
        }
    }
}// TypeIdentifier is returned by reference: dependent structures/unions are registered in this same method
void register_ClientUpdate_type_identifier(
        TypeIdentifierPair& type_ids_ClientUpdate)
{

    ReturnCode_t return_code_ClientUpdate {eprosima::fastdds::dds::RETCODE_OK};
    return_code_ClientUpdate =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::ClientUpdate", type_ids_ClientUpdate);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_ClientUpdate)
    {
        StructTypeFlag struct_flags_ClientUpdate = TypeObjectUtils::build_struct_type_flag(eprosima::fastdds::dds::xtypes::ExtensibilityKind::APPENDABLE,
                false, false);
        QualifiedTypeName type_name_ClientUpdate = "ai_train::ClientUpdate";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_ClientUpdate;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_ClientUpdate;
        CompleteTypeDetail detail_ClientUpdate = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_ClientUpdate, ann_custom_ClientUpdate, type_name_ClientUpdate.to_string());
        CompleteStructHeader header_ClientUpdate;
        header_ClientUpdate = TypeObjectUtils::build_complete_struct_header(TypeIdentifier(), detail_ClientUpdate);
        CompleteStructMemberSeq member_seq_ClientUpdate;
        {
            TypeIdentifierPair type_ids_client_id;
            ReturnCode_t return_code_client_id {eprosima::fastdds::dds::RETCODE_OK};
            return_code_client_id =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::ClientId", type_ids_client_id);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_client_id)
            {
                ::ai_train::register_ClientId_type_identifier(type_ids_client_id);
            }
            StructMemberFlag member_flags_client_id = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_client_id = 0x00000000;
            bool common_client_id_ec {false};
            CommonStructMember common_client_id {TypeObjectUtils::build_common_struct_member(member_id_client_id, member_flags_client_id, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_client_id, common_client_id_ec))};
            if (!common_client_id_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure client_id member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_client_id = "client_id";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_client_id;
            ann_custom_ClientUpdate.reset();
            CompleteMemberDetail detail_client_id = TypeObjectUtils::build_complete_member_detail(name_client_id, member_ann_builtin_client_id, ann_custom_ClientUpdate);
            CompleteStructMember member_client_id = TypeObjectUtils::build_complete_struct_member(common_client_id, detail_client_id);
            TypeObjectUtils::add_complete_struct_member(member_seq_ClientUpdate, member_client_id);
        }
        {
            TypeIdentifierPair type_ids_round_id;
            ReturnCode_t return_code_round_id {eprosima::fastdds::dds::RETCODE_OK};
            return_code_round_id =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::RoundId", type_ids_round_id);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_round_id)
            {
                ::ai_train::register_RoundId_type_identifier(type_ids_round_id);
            }
            StructMemberFlag member_flags_round_id = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_round_id = 0x00000001;
            bool common_round_id_ec {false};
            CommonStructMember common_round_id {TypeObjectUtils::build_common_struct_member(member_id_round_id, member_flags_round_id, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_round_id, common_round_id_ec))};
            if (!common_round_id_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure round_id member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_round_id = "round_id";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_round_id;
            ann_custom_ClientUpdate.reset();
            CompleteMemberDetail detail_round_id = TypeObjectUtils::build_complete_member_detail(name_round_id, member_ann_builtin_round_id, ann_custom_ClientUpdate);
            CompleteStructMember member_round_id = TypeObjectUtils::build_complete_struct_member(common_round_id, detail_round_id);
            TypeObjectUtils::add_complete_struct_member(member_seq_ClientUpdate, member_round_id);
        }
        {
            TypeIdentifierPair type_ids_num_samples;
            ReturnCode_t return_code_num_samples {eprosima::fastdds::dds::RETCODE_OK};
            return_code_num_samples =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "_uint64_t", type_ids_num_samples);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_num_samples)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                        "num_samples Structure member TypeIdentifier unknown to TypeObjectRegistry.");
                return;
            }
            StructMemberFlag member_flags_num_samples = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_num_samples = 0x00000002;
            bool common_num_samples_ec {false};
            CommonStructMember common_num_samples {TypeObjectUtils::build_common_struct_member(member_id_num_samples, member_flags_num_samples, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_num_samples, common_num_samples_ec))};
            if (!common_num_samples_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure num_samples member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_num_samples = "num_samples";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_num_samples;
            ann_custom_ClientUpdate.reset();
            CompleteMemberDetail detail_num_samples = TypeObjectUtils::build_complete_member_detail(name_num_samples, member_ann_builtin_num_samples, ann_custom_ClientUpdate);
            CompleteStructMember member_num_samples = TypeObjectUtils::build_complete_struct_member(common_num_samples, detail_num_samples);
            TypeObjectUtils::add_complete_struct_member(member_seq_ClientUpdate, member_num_samples);
        }
        {
            TypeIdentifierPair type_ids_data;
            ReturnCode_t return_code_data {eprosima::fastdds::dds::RETCODE_OK};
            return_code_data =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::Bytes", type_ids_data);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_data)
            {
                ::ai_train::register_Bytes_type_identifier(type_ids_data);
            }
            StructMemberFlag member_flags_data = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_data = 0x00000003;
            bool common_data_ec {false};
            CommonStructMember common_data {TypeObjectUtils::build_common_struct_member(member_id_data, member_flags_data, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_data, common_data_ec))};
            if (!common_data_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure data member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_data = "data";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_data;
            ann_custom_ClientUpdate.reset();
            CompleteMemberDetail detail_data = TypeObjectUtils::build_complete_member_detail(name_data, member_ann_builtin_data, ann_custom_ClientUpdate);
            CompleteStructMember member_data = TypeObjectUtils::build_complete_struct_member(common_data, detail_data);
            TypeObjectUtils::add_complete_struct_member(member_seq_ClientUpdate, member_data);
        }
        CompleteStructType struct_type_ClientUpdate = TypeObjectUtils::build_complete_struct_type(struct_flags_ClientUpdate, header_ClientUpdate, member_seq_ClientUpdate);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_struct_type_object(struct_type_ClientUpdate, type_name_ClientUpdate.to_string(), type_ids_ClientUpdate))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "ai_train::ClientUpdate already registered in TypeObjectRegistry for a different type.");
        }
    }
}// TypeIdentifier is returned by reference: dependent structures/unions are registered in this same method
void register_ModelBlob_type_identifier(
        TypeIdentifierPair& type_ids_ModelBlob)
{

    ReturnCode_t return_code_ModelBlob {eprosima::fastdds::dds::RETCODE_OK};
    return_code_ModelBlob =
        eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
        "ai_train::ModelBlob", type_ids_ModelBlob);
    if (eprosima::fastdds::dds::RETCODE_OK != return_code_ModelBlob)
    {
        StructTypeFlag struct_flags_ModelBlob = TypeObjectUtils::build_struct_type_flag(eprosima::fastdds::dds::xtypes::ExtensibilityKind::APPENDABLE,
                false, false);
        QualifiedTypeName type_name_ModelBlob = "ai_train::ModelBlob";
        eprosima::fastcdr::optional<AppliedBuiltinTypeAnnotations> type_ann_builtin_ModelBlob;
        eprosima::fastcdr::optional<AppliedAnnotationSeq> ann_custom_ModelBlob;
        CompleteTypeDetail detail_ModelBlob = TypeObjectUtils::build_complete_type_detail(type_ann_builtin_ModelBlob, ann_custom_ModelBlob, type_name_ModelBlob.to_string());
        CompleteStructHeader header_ModelBlob;
        header_ModelBlob = TypeObjectUtils::build_complete_struct_header(TypeIdentifier(), detail_ModelBlob);
        CompleteStructMemberSeq member_seq_ModelBlob;
        {
            TypeIdentifierPair type_ids_round_id;
            ReturnCode_t return_code_round_id {eprosima::fastdds::dds::RETCODE_OK};
            return_code_round_id =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::RoundId", type_ids_round_id);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_round_id)
            {
                ::ai_train::register_RoundId_type_identifier(type_ids_round_id);
            }
            StructMemberFlag member_flags_round_id = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_round_id = 0x00000000;
            bool common_round_id_ec {false};
            CommonStructMember common_round_id {TypeObjectUtils::build_common_struct_member(member_id_round_id, member_flags_round_id, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_round_id, common_round_id_ec))};
            if (!common_round_id_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure round_id member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_round_id = "round_id";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_round_id;
            ann_custom_ModelBlob.reset();
            CompleteMemberDetail detail_round_id = TypeObjectUtils::build_complete_member_detail(name_round_id, member_ann_builtin_round_id, ann_custom_ModelBlob);
            CompleteStructMember member_round_id = TypeObjectUtils::build_complete_struct_member(common_round_id, detail_round_id);
            TypeObjectUtils::add_complete_struct_member(member_seq_ModelBlob, member_round_id);
        }
        {
            TypeIdentifierPair type_ids_data;
            ReturnCode_t return_code_data {eprosima::fastdds::dds::RETCODE_OK};
            return_code_data =
                eprosima::fastdds::dds::DomainParticipantFactory::get_instance()->type_object_registry().get_type_identifiers(
                "ai_train::Bytes", type_ids_data);

            if (eprosima::fastdds::dds::RETCODE_OK != return_code_data)
            {
                ::ai_train::register_Bytes_type_identifier(type_ids_data);
            }
            StructMemberFlag member_flags_data = TypeObjectUtils::build_struct_member_flag(eprosima::fastdds::dds::xtypes::TryConstructFailAction::DISCARD,
                    false, false, false, false);
            MemberId member_id_data = 0x00000001;
            bool common_data_ec {false};
            CommonStructMember common_data {TypeObjectUtils::build_common_struct_member(member_id_data, member_flags_data, TypeObjectUtils::retrieve_complete_type_identifier(type_ids_data, common_data_ec))};
            if (!common_data_ec)
            {
                EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION, "Structure data member TypeIdentifier inconsistent.");
                return;
            }
            MemberName name_data = "data";
            eprosima::fastcdr::optional<AppliedBuiltinMemberAnnotations> member_ann_builtin_data;
            ann_custom_ModelBlob.reset();
            CompleteMemberDetail detail_data = TypeObjectUtils::build_complete_member_detail(name_data, member_ann_builtin_data, ann_custom_ModelBlob);
            CompleteStructMember member_data = TypeObjectUtils::build_complete_struct_member(common_data, detail_data);
            TypeObjectUtils::add_complete_struct_member(member_seq_ModelBlob, member_data);
        }
        CompleteStructType struct_type_ModelBlob = TypeObjectUtils::build_complete_struct_type(struct_flags_ModelBlob, header_ModelBlob, member_seq_ModelBlob);
        if (eprosima::fastdds::dds::RETCODE_BAD_PARAMETER ==
                TypeObjectUtils::build_and_register_struct_type_object(struct_type_ModelBlob, type_name_ModelBlob.to_string(), type_ids_ModelBlob))
        {
            EPROSIMA_LOG_ERROR(XTYPES_TYPE_REPRESENTATION,
                    "ai_train::ModelBlob already registered in TypeObjectRegistry for a different type.");
        }
    }
}
} // namespace ai_train

